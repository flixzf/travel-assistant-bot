import sys
import logging
import asyncio
import json
import os
import builtins
from dotenv import load_dotenv  # 추가된 부분
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ConversationHandler, ContextTypes
from korail2 import Korail, AdultPassenger, TrainType
from SRT import SRT, SeatType
from functools import partial
from datetime import datetime
import subprocess




# 환경 변수 로드
load_dotenv(dotenv_path="/Users/dh_archi/PycharmProjects/reservation/.env")

# 로깅 설정
logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)

# 대화 상태 정의
DEPARTURE, DESTINATION, DATE, TIME, TRAIN_SERVICE = range(5)


class SRTAutoPayment:
    def __init__(self, config=None):
        """
        SRT 결제 처리를 위한 핸들러 초기화

        Args:
            config (dict, optional): 결제 설정 정보를 담은 딕셔너리
                - payment_script_path: 결제 스크립트 경로
                - max_retries: 결제 재시도 횟수
                - retry_delay: 재시도 사이의 대기 시간(초)
        """
        # 기본 설정값 정의
        default_config = {
            'payment_script_path': 'srt_payment.py',
            'max_retries': 3,
            'retry_delay': 5
        }

        # 사용자 정의 설정과 기본 설정을 병합
        self.config = default_config
        if config:
            self.config.update(config)

        # 결제 스크립트 경로 확인
        self.payment_script_path = self.config['payment_script_path']
        if not os.path.exists(self.payment_script_path):
            raise FileNotFoundError(f"결제 스크립트를 찾을 수 없습니다: {self.payment_script_path}")

        # 결제 처리 상태 초기화
        self.current_transaction = None
        self.payment_status = None

        logger.info("SRTAutoPayment 핸들러 초기화 완료")

    async def process_payment(self, reservation_info, chat_id, context):
        """
        예약 정보를 기반으로 결제 프로세스 실행
        """
        self.current_transaction = {
            'reservation_id': reservation_info['reservation_number'],
            'train_info': reservation_info['train_info'],
            'start_time': datetime.now()
        }

        for attempt in range(self.config['max_retries']):
            try:
                env = os.environ.copy()
                env['SRT_RESERVATION_ID'] = reservation_info['reservation_number']

                logger.info(f"SRT 결제 시도 {attempt + 1}/{self.config['max_retries']}: "
                            f"예약번호 {reservation_info['reservation_number']}")

                process = await asyncio.create_subprocess_exec(
                    'python',
                    self.payment_script_path,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    env=env
                )

                stdout, stderr = await process.communicate()

                if process.returncode == 0:
                    await self._handle_payment_success(reservation_info, chat_id, context)
                    return True
                else:
                    error_msg = stderr.decode()
                    if attempt < self.config['max_retries'] - 1:
                        logger.warning(f"SRT 결제 실패, {self.config['retry_delay']}초 후 재시도: {error_msg}")
                        await asyncio.sleep(self.config['retry_delay'])
                    else:
                        # 모든 시도 실패 후 재예약 프로세스 시작
                        failure_msg = (
                            f"❌ SRT 결제 실패\n"
                            f"예약번호: {reservation_info['reservation_number']}\n"
                            f"열차: {reservation_info['train_info']}\n"
                            f"오류: {error_msg}\n"
                            f"9분 45초 후 재예약을 시도합니다."
                        )
                        await context.bot.send_message(chat_id=chat_id, text=failure_msg)
                        logger.error(f"SRT 결제 실패: {error_msg}")

                        # 실패한 예약 정보에서 원래 예약 정보 추출
                        train_info = reservation_info['train_info']
                        date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':',
                                                                                                           '') + '00'
                        date = date_time[:8]
                        time = date_time[8:14]

                        # 9분 45초 대기 후 재예약 시도
                        await asyncio.sleep(585)  # 9분 45초 = 585초

                        # 재예약 시도
                        await context.bot.send_message(chat_id=chat_id, text="재예약을 시도합니다.")
                        train_reservation.search_and_reserve(
                            context.user_data['departure'],
                            context.user_data['destination'],
                            date,
                            time,
                            'SRT',
                            chat_id,
                            context
                        )
                        return False

            except Exception as e:
                logger.error(f"SRT 결제 프로세스 오류: {str(e)}")
                if attempt == self.config['max_retries'] - 1:
                    error_msg = (
                        f"⚠️ SRT 결제 프로세스 오류\n"
                        f"예약번호: {reservation_info['reservation_number']}\n"
                        f"열차: {reservation_info['train_info']}\n"
                        f"오류: {str(e)}\n"
                        f"9분 45초 후 재예약을 시도합니다."
                    )
                    await context.bot.send_message(chat_id=chat_id, text=error_msg)

                    # 실패한 예약 정보에서 원래 예약 정보 추출
                    train_info = reservation_info['train_info']
                    date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':', '') + '00'
                    date = date_time[:8]
                    time = date_time[8:14]

                    # 9분 45초 대기 후 재예약 시도
                    await asyncio.sleep(585)  # 9분 45초 = 585초

                    # 재예약 시도
                    await context.bot.send_message(chat_id=chat_id, text="재예약을 시도합니다.")
                    train_reservation.search_and_reserve(
                        context.user_data['departure'],
                        context.user_data['destination'],
                        date,
                        time,
                        'SRT',
                        chat_id,
                        context
                    )
                    return False

    async def _handle_payment_success(self, reservation_info, chat_id, context):
        """결제 성공 처리"""
        success_msg = (
            f"🎉 SRT 예약 및 결제 완료!\n"
            f"예약번호: {reservation_info['reservation_number']}\n"
            f"열차: {reservation_info['train_info']}\n"
            f"결제 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )
        await context.bot.send_message(chat_id=chat_id, text=success_msg)
        logger.info(f"SRT 결제 성공: {reservation_info['reservation_number']}")
        self.payment_status = 'SUCCESS'

    async def _handle_payment_failure(self, reservation_info, error_msg, chat_id, context):
        """결제 실패 처리"""
        failure_msg = (
            f"❌ SRT 결제 실패\n"
            f"예약번호: {reservation_info['reservation_number']}\n"
            f"열차: {reservation_info['train_info']}\n"
            f"오류: {error_msg}\n"
            f"9분 45초 후 재예약을 시도합니다."
        )
        await context.bot.send_message(chat_id=chat_id, text=failure_msg)
        logger.error(f"SRT 결제 실패: {error_msg}")
        self.payment_status = 'FAILED'

        # 실패한 예약 정보에서 원래 예약 정보 추출
        train_info = reservation_info['train_info']
        date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':', '') + '00'
        date = date_time[:8]
        time = date_time[8:14]

        # 9분 45초 대기 후 재예약 시도
        await asyncio.sleep(585)  # 9분 45초 = 585초

        # 재예약 시도
        await context.bot.send_message(chat_id=chat_id, text="재예약을 시도합니다.")
        train_reservation.search_and_reserve(
            context.user_data['departure'],
            context.user_data['destination'],
            date,
            time,
            'SRT',  # 또는 'KTX'
            chat_id,
            context
        )
class KorailAutoPayment:
    def __init__(self):
        self.payment_script_path = "korail_payment.py"  # 두 번째 파일의 경로

    async def process_payment(self, reservation_info, chat_id, context):
        """예약 성공 후 결제 처리 및 알림 전송"""
        logger.info(f"결제 프로세스 시작: {reservation_info}")

        # 환경변수 설정
        env = os.environ.copy()
        env['KORAIL_RESERVATION_ID'] = reservation_info['rsv_id']

        try:
            # 결제 스크립트 실행
            process = await asyncio.create_subprocess_exec(
                'python', self.payment_script_path,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env
            )

            stdout, stderr = await process.communicate()

            # 결제 결과 확인 및 메시지 전송
            if process.returncode == 0:
                success_msg = (
                    f"🎉 예약 및 결제 완료!\n"
                    f"예약번호: {reservation_info['rsv_id']}\n"
                    f"열차: {reservation_info['train_info']}\n"
                    f"결제 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                )
                await context.bot.send_message(chat_id=chat_id, text=success_msg)
                logger.info(f"결제 성공: {reservation_info['rsv_id']}")

            else:
                error_msg = (
                    f"❌ 결제 실패\n"
                    f"예약번호: {reservation_info['rsv_id']}\n"
                    f"열차: {reservation_info['train_info']}\n"
                    f"오류: {stderr.decode()}\n"
                    f"9분 45초 후 재예약을 시도합니다."
                )
                await context.bot.send_message(chat_id=chat_id, text=error_msg)
                logger.error(f"결제 실패: {stderr.decode()}")

                # 실패한 예약 정보에서 원래 예약 정보 추출
                train_info = reservation_info['train_info']
                date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':', '') + '00'
                date = date_time[:8]
                time = date_time[8:14]

                # 9분 45초 대기 후 재예약 시도
                await asyncio.sleep(585)  # 9분 45초 = 585초

                # 재예약 시도
                await context.bot.send_message(chat_id=chat_id, text="재예약을 시도합니다.")
                train_reservation.search_and_reserve(
                    context.user_data['departure'],
                    context.user_data['destination'],
                    date,
                    time,
                    'KTX',
                    chat_id,
                    context
                )

        except Exception as e:
            error_msg = (
                f"⚠️ 결제 프로세스 오류\n"
                f"예약번호: {reservation_info['rsv_id']}\n"
                f"열차: {reservation_info['train_info']}\n"
                f"오류: {str(e)}\n"
                f"9분 45초 후 재예약을 시도합니다."
            )
            await context.bot.send_message(chat_id=chat_id, text=error_msg)
            logger.error(f"결제 프로세스 오류: {str(e)}")

            # 실패한 예약 정보에서 원래 예약 정보 추출
            train_info = reservation_info['train_info']
            date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':', '') + '00'
            date = date_time[:8]
            time = date_time[8:14]

            # 9분 45초 대기 후 재예약 시도
            await asyncio.sleep(585)  # 9분 45초 = 585초

            # 재예약 시도
            await context.bot.send_message(chat_id=chat_id, text="재예약을 시도합니다.")
            train_reservation.search_and_reserve(
                context.user_data['departure'],
                context.user_data['destination'],
                date,
                time,
                'KTX',
                chat_id,
                context
            )

class StatusManager:
    def __init__(self, status_file="reservation_status.json"):
        self.status_file = status_file
        self.current_status = None  # 메모리상의 상태
        self.stop_event = asyncio.Event()  # 중단 이벤트 생성
        self.initialize_status()

    def initialize_status(self):
        """상태 초기화"""
        self.current_status = {
            'is_running': False,
            'should_stop': False,
            'chat_id': None,
            'last_check': datetime.now().isoformat()
        }
        self.stop_event.clear()  # 중단 이벤트 초기화
        self._save_status(self.current_status)

    def _save_status(self, status):
        """상태 파일 저장"""
        self.current_status = status
        with builtins.open(self.status_file, 'w') as f:
            json.dump(status, f)

    def _load_status(self):
        """상태 파일 로드"""
        if not self.current_status:
            if os.path.exists(self.status_file):
                with builtins.open(self.status_file, 'r') as f:
                    self.current_status = json.load(f)
            else:
                self.initialize_status()
        return self.current_status

    def start_reservation(self, chat_id):
        """예약 시작"""
        self.current_status = {
            'is_running': True,
            'should_stop': False,
            'chat_id': chat_id,
            'last_check': datetime.now().isoformat()
        }
        self.stop_event.clear()  # 중단 이벤트 초기화
        self._save_status(self.current_status)
        logger.info(f"예약 시작 - chat_id: {chat_id}")

    def stop_reservation(self, chat_id):
        """예약 중단"""
        status = self._load_status()
        if status and str(status['chat_id']) == str(chat_id):
            status['should_stop'] = True
            self.stop_event.set()  # 중단 이벤트 설정
            self._save_status(status)
            logger.info(f"예약 중단 요청 - chat_id: {chat_id}")
            return True
        return False

    def should_stop(self, chat_id):
        """중단 상태 확인"""
        status = self._load_status()
        return status and str(status['chat_id']) == str(chat_id) and status['should_stop']

    def cleanup(self):
        """상태 정리"""
        try:
            self.initialize_status()
            logger.info("상태 초기화 완료")
        except Exception as e:
            logger.error(f"상태 초기화 중 오류 발생: {e}")

class TrainReservation:
    def __init__(self):
        korail_user = os.environ.get('KORAIL_USER')
        korail_pass = os.environ.get('KORAIL_PASS')
        srt_user = os.environ.get('SRT_USER_num')  # SRT_USER_num 사용
        srt_pass = os.environ.get('SRT_PASS')

        # 디버깅을 위한 로깅 추가
        logger.info(f"SRT User: {srt_user}")
        
        if not all([korail_user, korail_pass, srt_user, srt_pass]):
            logger.error("환경 변수가 설정되지 않았습니다.")
            sys.exit(1)

        self.korail = Korail(korail_user, korail_pass, auto_login=True)
        self.srt = SRT(
            srt_user.strip(),  # 공백 제거
            srt_pass.strip()   # 공백 제거
        )

        # 민감한 정보를 하드코딩하지 않고 환경 변수 사용
        self.korail = Korail(korail_user, korail_pass, auto_login=True)
        self.srt = SRT(srt_user, srt_pass)
        self.srt.login()
        self.RATE_LIMIT_DELAY = 0.9
        self.ATTEMPTS_PER_CYCLE = 10
        self.status_manager = StatusManager()
        self.reservation_task = None

    def search_and_reserve(self, dep, arr, date, time, service, chat_id, context):
        """예약 프로세스 시작"""
        self.status_manager.start_reservation(chat_id)
        loop = asyncio.get_event_loop()
        self.reservation_task = loop.create_task(
            self._reserve_process(dep, arr, date, time, service, chat_id, context)
        )

    async def _reserve_process(self, dep, arr, date, time, service, chat_id, context):
        try:
            if service == 'KTX':
                return await self.reserve_ktx(dep, arr, date, time, chat_id, context)
            elif service == 'SRT':
                return await self.reserve_srt(dep, arr, date, time, chat_id, context)
            else:
                return "잘못된 열차 서비스 선택입니다."
        except asyncio.CancelledError:
            logger.info("예약 프로세스가 취소되었습니다.")
            await context.bot.send_message(chat_id=chat_id, text="예약 프로세스가 취소되었습니다.")
            raise
        finally:
            self.status_manager.cleanup()

    def stop_reservation_task(self):
        if self.reservation_task:
            self.reservation_task.cancel()
            self.reservation_task = None

    async def reserve_ktx(self, dep, arr, date, time, chat_id, context):
        total_attempt_count = 0
        loop = asyncio.get_event_loop()

        while not self.status_manager.stop_event.is_set():
            for _ in range(self.ATTEMPTS_PER_CYCLE):
                if self.status_manager.stop_event.is_set():
                    logger.info("KTX 예약 중단 요청 감지")
                    return "사용자 요청으로 예약이 중단되었습니다."

                total_attempt_count += 1
                try:
                    if self.status_manager.stop_event.is_set():
                        return "사용자 요청으로 예약이 중단되었습니다."

                    trains = await loop.run_in_executor(None, partial(
                        self.korail.search_train,
                        dep, arr, date, time,
                        passengers=[AdultPassenger(1)],
                        train_type=[TrainType.KTX],
                        include_no_seats=True
                    ))

                    if not trains:
                        # 열차가 없으면 다음 루프로
                        await asyncio.sleep(self.RATE_LIMIT_DELAY)
                        continue

                    train = trains[0]

                    train_info = (f"{date[:4]}/{date[4:6]}/{date[6:]} "
                                f"{train.dep_time[:2]}:{train.dep_time[2:4]} "
                                f"{train.train_no}번 열차")

                    try:
                        reservation = await loop.run_in_executor(None, partial(
                            self.korail.reserve,
                            train,
                            [AdultPassenger(1)]
                        ))

                        if reservation:
                            # 예약 성공
                            success_msg = (
                                f"KTX 예약 성공!\n"
                                f"열차: {train_info}\n"
                                f"출발: {train.dep_name} -> 도착: {train.arr_name}\n"
                                f"예약번호: {reservation.rsv_id}"
                            )
                            logger.info(f"KTX 예약 성공: {train_info}")
                            await context.bot.send_message(chat_id=chat_id, text=success_msg)

                            # 결제 처리 시작
                            payment_handler = KorailAutoPayment()
                            reservation_info = {
                                'rsv_id': reservation.rsv_id,
                                'train_info': train_info
                            }
                            await payment_handler.process_payment(reservation_info, chat_id, context)

                            return success_msg

                    except Exception as e:
                        error_message = str(e)
                        logger.error(f"KTX 예약 실패 - {train_info} - 사유: {error_message}")

                        if 'WRR800029' in error_message:
                            # 동일한 예약이 이미 존재함 => 즉시 종료
                            warning_msg = (
                                f"이미 동일한 예약이 존재합니다. 예약 프로세스를 종료합니다.\n"
                                f"열차: {train_info}"
                            )
                            logger.info(warning_msg)
                            await context.bot.send_message(chat_id=chat_id, text=warning_msg)
                            return warning_msg  # 여기서 즉시 함수 종료

                    await asyncio.sleep(self.RATE_LIMIT_DELAY)

                except Exception as e:
                    logger.error(f"KTX 검색 오류: {str(e)}")
                    await asyncio.sleep(self.RATE_LIMIT_DELAY)

            # 여기까지 왔다면 해당 사이클에서 예약 성공/종료 조건을 못 찾음
            if self.status_manager.stop_event.is_set():
                return "사용자 요청으로 예약이 중단되었습니다."

            logger.info(f"KTX 예약 진행 중... (시도 횟수: {total_attempt_count}회)")
            await asyncio.sleep(0.5)

        return "예약 프로세스가 중단되었습니다."


    async def reserve_srt(self, dep, arr, date, time, chat_id, context):
        # 세션 재설정 로직 강화
        try:
            self.srt = SRT(os.environ.get('SRT_USER'), os.environ.get('SRT_PASS'))
            self.srt.login()
        except Exception as e:
            logger.error(f"SRT 로그인 실패: {str(e)}")
            await context.bot.send_message(chat_id=chat_id, text="SRT 로그인 실패. 다시 시도합니다.")
            await asyncio.sleep(2)

        total_attempt_count = 0
        loop = asyncio.get_event_loop()

        while not self.status_manager.stop_event.is_set():
            for _ in range(self.ATTEMPTS_PER_CYCLE):
                if self.status_manager.stop_event.is_set():
                    return "사용자 요청으로 예약이 중단되었습니다."

                total_attempt_count += 1
                try:
                    # NetFunnel 오류 방지를 위한 딜레이 추가
                    await asyncio.sleep(1.5)  # 1.5초 대기

                    trains = await loop.run_in_executor(None, partial(
                        self.srt.search_train,
                        dep, arr, date, time,
                        available_only=False
                    ))

                    if not trains:
                        continue

                    train = trains[0]
                    # dep_station, arr_station 대신 dep_name, arr_name 사용
                    train_info = (f"{date[:4]}/{date[4:6]}/{date[6:]} "
                                  f"{train.dep_time[:2]}:{train.dep_time[2:4]} "
                                  f"SRT {train.train_number}번 열차")

                    try:
                        # NetFunnel 오류 방지를 위한 딜레이 추가
                        await asyncio.sleep(1)

                        reservation = await loop.run_in_executor(None, partial(
                            self.srt.reserve,
                            train,
                            special_seat=SeatType.GENERAL_FIRST
                        ))

                        if reservation:
                            success_msg = (
                                f"SRT 예약 성공!\n"
                                f"열차: {train_info}\n"
                                f"출발: {train.dep_station_name} -> 도착: {train.arr_station_name}\n"
                                f"예약번호: {reservation.reservation_number}"
                            )
                            logger.info(f"SRT 예약 성공: {train_info}")
                            await context.bot.send_message(chat_id=chat_id, text=success_msg)

                            # 결제 처리 시작
                            payment_handler = SRTAutoPayment()
                            reservation_info = {
                                'reservation_number': reservation.reservation_number,
                                'train_info': train_info
                            }
                            await payment_handler.process_payment(reservation_info, chat_id, context)

                            return success_msg

                    except Exception as e:
                        error_message = str(e)
                        logger.error(f"SRT 예약 실패 - {train_info} - 사유: {error_message}")
                        await asyncio.sleep(1)  # 오류 발생 시 추가 딜레이

                except Exception as e:
                    logger.error(f"SRT 검색 오류: {str(e)}")
                    await asyncio.sleep(2)  # 검색 오류 시 더 긴 딜레이

            if self.status_manager.stop_event.is_set():
                return "사용자 요청으로 예약이 중단되었습니다."

            logger.info(f"SRT 예약 진행 중... (시도 횟수: {total_attempt_count}회)")
            await asyncio.sleep(1)

        return "예약 프로세스가 중단되었습니다."

train_reservation = TrainReservation()

async def start_search(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('예약할 열차 서비스를 선택하세요 (/ktx 또는 /srt):')
    return TRAIN_SERVICE

async def set_ktx(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['service'] = 'KTX'
    await update.message.reply_text('출발지를 입력해주세요:')
    return DEPARTURE

async def set_srt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['service'] = 'SRT'
    await update.message.reply_text('출발지를 입력해주세요:')
    return DEPARTURE

async def departure(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['departure'] = update.message.text
    await update.message.reply_text('도착지를 입력해주세요:')
    return DESTINATION

async def destination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['destination'] = update.message.text
    await update.message.reply_text('여행 날짜를 입력해주세요 (예: 20240324):')
    return DATE

async def date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        input_date = update.message.text
        # 날짜 형식 검증
        datetime.strptime(input_date, '%Y%m%d')
        context.user_data['date'] = input_date
        await update.message.reply_text('출발 시간을 입력해주세요 (예: 130000):')
        return TIME
    except ValueError:
        await update.message.reply_text('올바른 날짜 형식이 아닙니다. YYYYMMDD 형식으로 다시 입력해주세요 (예: 20240324):')
        return DATE

async def time(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        input_time = update.message.text
        datetime.strptime(input_time, '%H%M%S')
        context.user_data['time'] = input_time
        await update.message.reply_text('예약을 시작합니다. 중단하려면 /stop 명령어를 사용하세요.')

        # 예약 프로세스를 백그라운드에서 시작
        train_reservation.search_and_reserve(
            context.user_data['departure'],
            context.user_data['destination'],
            context.user_data['date'],
            context.user_data['time'],
            context.user_data['service'],
            update.effective_chat.id,
            context
        )

        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text('올바른 시간 형식이 아닙니다. HHMMSS 형식으로 다시 입력해주세요 (예: 130000):')
        return TIME

async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """예약 중단 명령어 처리"""
    chat_id = update.effective_chat.id
    logger.info(f"Stop 명령어 수신 from user {chat_id}")

    train_reservation.stop_reservation_task()

    if train_reservation.status_manager.stop_reservation(chat_id):
        await update.message.reply_text('예약을 중단합니다. 잠시만 기다려주세요...')
    else:
        await update.message.reply_text('현재 실행 중인 예약이 없습니다.')

    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('예약 프로세스가 취소되었습니다.')
    return ConversationHandler.END

def main():
    # 이벤트 루프 설정
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    # 환경 변수에서 Telegram Bot Token 가져오기
    telegram_bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')

    # 환경 변수 유효성 검사
    if not telegram_bot_token:
        logger.error("TELEGRAM_BOT_TOKEN 환경 변수가 설정되지 않았습니다.")
        sys.exit(1)

    application = Application.builder().token(telegram_bot_token).build()

    # stop 명령어 핸들러를 최우선 등록
    application.add_handler(CommandHandler('stop', stop), group=-1)

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start_search)],
        states={
            TRAIN_SERVICE: [CommandHandler('ktx', set_ktx), CommandHandler('srt', set_srt)],
            DEPARTURE: [MessageHandler(filters.TEXT & ~filters.COMMAND, departure)],
            DESTINATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, destination)],
            DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, date)],
            TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, time)]
        },
        fallbacks=[CommandHandler('stop', stop), CommandHandler('cancel', cancel)]
    )

    application.add_handler(conv_handler)

    # 높은 우선순위로 stop 핸들러 다시 등록
    application.add_handler(CommandHandler('stop', stop), group=1)

    application.run_polling()

if __name__ == '__main__':
    main()





