import sys
import logging
import asyncio
import json
import os
import builtins
from dotenv import load_dotenv  # ì¶”ê°€ëœ ë¶€ë¶„
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ConversationHandler, ContextTypes
from korail2 import Korail, AdultPassenger, TrainType
from SRT import SRT, SeatType
from functools import partial
from datetime import datetime
import subprocess




# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
load_dotenv(dotenv_path="/Users/dh_archi/PycharmProjects/reservation/.env")

# ë¡œê¹… ì„¤ì •
logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)

# ëŒ€í™” ìƒíƒœ ì •ì˜
DEPARTURE, DESTINATION, DATE, TIME, TRAIN_SERVICE = range(5)


class SRTAutoPayment:
    def __init__(self, config=None):
        """
        SRT ê²°ì œ ì²˜ë¦¬ë¥¼ ìœ„í•œ í•¸ë“¤ëŸ¬ ì´ˆê¸°í™”

        Args:
            config (dict, optional): ê²°ì œ ì„¤ì • ì •ë³´ë¥¼ ë‹´ì€ ë”•ì…”ë„ˆë¦¬
                - payment_script_path: ê²°ì œ ìŠ¤í¬ë¦½íŠ¸ ê²½ë¡œ
                - max_retries: ê²°ì œ ì¬ì‹œë„ íšŸìˆ˜
                - retry_delay: ì¬ì‹œë„ ì‚¬ì´ì˜ ëŒ€ê¸° ì‹œê°„(ì´ˆ)
        """
        # ê¸°ë³¸ ì„¤ì •ê°’ ì •ì˜
        default_config = {
            'payment_script_path': 'srt_payment.py',
            'max_retries': 3,
            'retry_delay': 5
        }

        # ì‚¬ìš©ì ì •ì˜ ì„¤ì •ê³¼ ê¸°ë³¸ ì„¤ì •ì„ ë³‘í•©
        self.config = default_config
        if config:
            self.config.update(config)

        # ê²°ì œ ìŠ¤í¬ë¦½íŠ¸ ê²½ë¡œ í™•ì¸
        self.payment_script_path = self.config['payment_script_path']
        if not os.path.exists(self.payment_script_path):
            raise FileNotFoundError(f"ê²°ì œ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {self.payment_script_path}")

        # ê²°ì œ ì²˜ë¦¬ ìƒíƒœ ì´ˆê¸°í™”
        self.current_transaction = None
        self.payment_status = None

        logger.info("SRTAutoPayment í•¸ë“¤ëŸ¬ ì´ˆê¸°í™” ì™„ë£Œ")

    async def process_payment(self, reservation_info, chat_id, context):
        """
        ì˜ˆì•½ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê²°ì œ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
        """
        self.current_transaction = {
            'reservation_id': reservation_info['reservation_number'],
            'train_info': reservation_info['train_info'],
            'start_time': datetime.now()
        }

        for attempt in range(self.config['max_retries']):
            try:
                env = os.environ.copy()
                env['SRT_RESERVATION_ID'] = reservation_info['reservation_number']

                logger.info(f"SRT ê²°ì œ ì‹œë„ {attempt + 1}/{self.config['max_retries']}: "
                            f"ì˜ˆì•½ë²ˆí˜¸ {reservation_info['reservation_number']}")

                process = await asyncio.create_subprocess_exec(
                    'python',
                    self.payment_script_path,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    env=env
                )

                stdout, stderr = await process.communicate()

                if process.returncode == 0:
                    await self._handle_payment_success(reservation_info, chat_id, context)
                    return True
                else:
                    error_msg = stderr.decode()
                    if attempt < self.config['max_retries'] - 1:
                        logger.warning(f"SRT ê²°ì œ ì‹¤íŒ¨, {self.config['retry_delay']}ì´ˆ í›„ ì¬ì‹œë„: {error_msg}")
                        await asyncio.sleep(self.config['retry_delay'])
                    else:
                        # ëª¨ë“  ì‹œë„ ì‹¤íŒ¨ í›„ ì¬ì˜ˆì•½ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
                        failure_msg = (
                            f"âŒ SRT ê²°ì œ ì‹¤íŒ¨\n"
                            f"ì˜ˆì•½ë²ˆí˜¸: {reservation_info['reservation_number']}\n"
                            f"ì—´ì°¨: {reservation_info['train_info']}\n"
                            f"ì˜¤ë¥˜: {error_msg}\n"
                            f"9ë¶„ 45ì´ˆ í›„ ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤."
                        )
                        await context.bot.send_message(chat_id=chat_id, text=failure_msg)
                        logger.error(f"SRT ê²°ì œ ì‹¤íŒ¨: {error_msg}")

                        # ì‹¤íŒ¨í•œ ì˜ˆì•½ ì •ë³´ì—ì„œ ì›ë˜ ì˜ˆì•½ ì •ë³´ ì¶”ì¶œ
                        train_info = reservation_info['train_info']
                        date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':',
                                                                                                           '') + '00'
                        date = date_time[:8]
                        time = date_time[8:14]

                        # 9ë¶„ 45ì´ˆ ëŒ€ê¸° í›„ ì¬ì˜ˆì•½ ì‹œë„
                        await asyncio.sleep(585)  # 9ë¶„ 45ì´ˆ = 585ì´ˆ

                        # ì¬ì˜ˆì•½ ì‹œë„
                        await context.bot.send_message(chat_id=chat_id, text="ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤.")
                        train_reservation.search_and_reserve(
                            context.user_data['departure'],
                            context.user_data['destination'],
                            date,
                            time,
                            'SRT',
                            chat_id,
                            context
                        )
                        return False

            except Exception as e:
                logger.error(f"SRT ê²°ì œ í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜: {str(e)}")
                if attempt == self.config['max_retries'] - 1:
                    error_msg = (
                        f"âš ï¸ SRT ê²°ì œ í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜\n"
                        f"ì˜ˆì•½ë²ˆí˜¸: {reservation_info['reservation_number']}\n"
                        f"ì—´ì°¨: {reservation_info['train_info']}\n"
                        f"ì˜¤ë¥˜: {str(e)}\n"
                        f"9ë¶„ 45ì´ˆ í›„ ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤."
                    )
                    await context.bot.send_message(chat_id=chat_id, text=error_msg)

                    # ì‹¤íŒ¨í•œ ì˜ˆì•½ ì •ë³´ì—ì„œ ì›ë˜ ì˜ˆì•½ ì •ë³´ ì¶”ì¶œ
                    train_info = reservation_info['train_info']
                    date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':', '') + '00'
                    date = date_time[:8]
                    time = date_time[8:14]

                    # 9ë¶„ 45ì´ˆ ëŒ€ê¸° í›„ ì¬ì˜ˆì•½ ì‹œë„
                    await asyncio.sleep(585)  # 9ë¶„ 45ì´ˆ = 585ì´ˆ

                    # ì¬ì˜ˆì•½ ì‹œë„
                    await context.bot.send_message(chat_id=chat_id, text="ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤.")
                    train_reservation.search_and_reserve(
                        context.user_data['departure'],
                        context.user_data['destination'],
                        date,
                        time,
                        'SRT',
                        chat_id,
                        context
                    )
                    return False

    async def _handle_payment_success(self, reservation_info, chat_id, context):
        """ê²°ì œ ì„±ê³µ ì²˜ë¦¬"""
        success_msg = (
            f"ğŸ‰ SRT ì˜ˆì•½ ë° ê²°ì œ ì™„ë£Œ!\n"
            f"ì˜ˆì•½ë²ˆí˜¸: {reservation_info['reservation_number']}\n"
            f"ì—´ì°¨: {reservation_info['train_info']}\n"
            f"ê²°ì œ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )
        await context.bot.send_message(chat_id=chat_id, text=success_msg)
        logger.info(f"SRT ê²°ì œ ì„±ê³µ: {reservation_info['reservation_number']}")
        self.payment_status = 'SUCCESS'

    async def _handle_payment_failure(self, reservation_info, error_msg, chat_id, context):
        """ê²°ì œ ì‹¤íŒ¨ ì²˜ë¦¬"""
        failure_msg = (
            f"âŒ SRT ê²°ì œ ì‹¤íŒ¨\n"
            f"ì˜ˆì•½ë²ˆí˜¸: {reservation_info['reservation_number']}\n"
            f"ì—´ì°¨: {reservation_info['train_info']}\n"
            f"ì˜¤ë¥˜: {error_msg}\n"
            f"9ë¶„ 45ì´ˆ í›„ ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤."
        )
        await context.bot.send_message(chat_id=chat_id, text=failure_msg)
        logger.error(f"SRT ê²°ì œ ì‹¤íŒ¨: {error_msg}")
        self.payment_status = 'FAILED'

        # ì‹¤íŒ¨í•œ ì˜ˆì•½ ì •ë³´ì—ì„œ ì›ë˜ ì˜ˆì•½ ì •ë³´ ì¶”ì¶œ
        train_info = reservation_info['train_info']
        date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':', '') + '00'
        date = date_time[:8]
        time = date_time[8:14]

        # 9ë¶„ 45ì´ˆ ëŒ€ê¸° í›„ ì¬ì˜ˆì•½ ì‹œë„
        await asyncio.sleep(585)  # 9ë¶„ 45ì´ˆ = 585ì´ˆ

        # ì¬ì˜ˆì•½ ì‹œë„
        await context.bot.send_message(chat_id=chat_id, text="ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤.")
        train_reservation.search_and_reserve(
            context.user_data['departure'],
            context.user_data['destination'],
            date,
            time,
            'SRT',  # ë˜ëŠ” 'KTX'
            chat_id,
            context
        )
class KorailAutoPayment:
    def __init__(self):
        self.payment_script_path = "korail_payment.py"  # ë‘ ë²ˆì§¸ íŒŒì¼ì˜ ê²½ë¡œ

    async def process_payment(self, reservation_info, chat_id, context):
        """ì˜ˆì•½ ì„±ê³µ í›„ ê²°ì œ ì²˜ë¦¬ ë° ì•Œë¦¼ ì „ì†¡"""
        logger.info(f"ê²°ì œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘: {reservation_info}")

        # í™˜ê²½ë³€ìˆ˜ ì„¤ì •
        env = os.environ.copy()
        env['KORAIL_RESERVATION_ID'] = reservation_info['rsv_id']

        try:
            # ê²°ì œ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
            process = await asyncio.create_subprocess_exec(
                'python', self.payment_script_path,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env
            )

            stdout, stderr = await process.communicate()

            # ê²°ì œ ê²°ê³¼ í™•ì¸ ë° ë©”ì‹œì§€ ì „ì†¡
            if process.returncode == 0:
                success_msg = (
                    f"ğŸ‰ ì˜ˆì•½ ë° ê²°ì œ ì™„ë£Œ!\n"
                    f"ì˜ˆì•½ë²ˆí˜¸: {reservation_info['rsv_id']}\n"
                    f"ì—´ì°¨: {reservation_info['train_info']}\n"
                    f"ê²°ì œ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                )
                await context.bot.send_message(chat_id=chat_id, text=success_msg)
                logger.info(f"ê²°ì œ ì„±ê³µ: {reservation_info['rsv_id']}")

            else:
                error_msg = (
                    f"âŒ ê²°ì œ ì‹¤íŒ¨\n"
                    f"ì˜ˆì•½ë²ˆí˜¸: {reservation_info['rsv_id']}\n"
                    f"ì—´ì°¨: {reservation_info['train_info']}\n"
                    f"ì˜¤ë¥˜: {stderr.decode()}\n"
                    f"9ë¶„ 45ì´ˆ í›„ ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤."
                )
                await context.bot.send_message(chat_id=chat_id, text=error_msg)
                logger.error(f"ê²°ì œ ì‹¤íŒ¨: {stderr.decode()}")

                # ì‹¤íŒ¨í•œ ì˜ˆì•½ ì •ë³´ì—ì„œ ì›ë˜ ì˜ˆì•½ ì •ë³´ ì¶”ì¶œ
                train_info = reservation_info['train_info']
                date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':', '') + '00'
                date = date_time[:8]
                time = date_time[8:14]

                # 9ë¶„ 45ì´ˆ ëŒ€ê¸° í›„ ì¬ì˜ˆì•½ ì‹œë„
                await asyncio.sleep(585)  # 9ë¶„ 45ì´ˆ = 585ì´ˆ

                # ì¬ì˜ˆì•½ ì‹œë„
                await context.bot.send_message(chat_id=chat_id, text="ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤.")
                train_reservation.search_and_reserve(
                    context.user_data['departure'],
                    context.user_data['destination'],
                    date,
                    time,
                    'KTX',
                    chat_id,
                    context
                )

        except Exception as e:
            error_msg = (
                f"âš ï¸ ê²°ì œ í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜\n"
                f"ì˜ˆì•½ë²ˆí˜¸: {reservation_info['rsv_id']}\n"
                f"ì—´ì°¨: {reservation_info['train_info']}\n"
                f"ì˜¤ë¥˜: {str(e)}\n"
                f"9ë¶„ 45ì´ˆ í›„ ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤."
            )
            await context.bot.send_message(chat_id=chat_id, text=error_msg)
            logger.error(f"ê²°ì œ í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜: {str(e)}")

            # ì‹¤íŒ¨í•œ ì˜ˆì•½ ì •ë³´ì—ì„œ ì›ë˜ ì˜ˆì•½ ì •ë³´ ì¶”ì¶œ
            train_info = reservation_info['train_info']
            date_time = train_info.split()[0].replace('/', '') + train_info.split()[1].replace(':', '') + '00'
            date = date_time[:8]
            time = date_time[8:14]

            # 9ë¶„ 45ì´ˆ ëŒ€ê¸° í›„ ì¬ì˜ˆì•½ ì‹œë„
            await asyncio.sleep(585)  # 9ë¶„ 45ì´ˆ = 585ì´ˆ

            # ì¬ì˜ˆì•½ ì‹œë„
            await context.bot.send_message(chat_id=chat_id, text="ì¬ì˜ˆì•½ì„ ì‹œë„í•©ë‹ˆë‹¤.")
            train_reservation.search_and_reserve(
                context.user_data['departure'],
                context.user_data['destination'],
                date,
                time,
                'KTX',
                chat_id,
                context
            )

class StatusManager:
    def __init__(self, status_file="reservation_status.json"):
        self.status_file = status_file
        self.current_status = None  # ë©”ëª¨ë¦¬ìƒì˜ ìƒíƒœ
        self.stop_event = asyncio.Event()  # ì¤‘ë‹¨ ì´ë²¤íŠ¸ ìƒì„±
        self.initialize_status()

    def initialize_status(self):
        """ìƒíƒœ ì´ˆê¸°í™”"""
        self.current_status = {
            'is_running': False,
            'should_stop': False,
            'chat_id': None,
            'last_check': datetime.now().isoformat()
        }
        self.stop_event.clear()  # ì¤‘ë‹¨ ì´ë²¤íŠ¸ ì´ˆê¸°í™”
        self._save_status(self.current_status)

    def _save_status(self, status):
        """ìƒíƒœ íŒŒì¼ ì €ì¥"""
        self.current_status = status
        with builtins.open(self.status_file, 'w') as f:
            json.dump(status, f)

    def _load_status(self):
        """ìƒíƒœ íŒŒì¼ ë¡œë“œ"""
        if not self.current_status:
            if os.path.exists(self.status_file):
                with builtins.open(self.status_file, 'r') as f:
                    self.current_status = json.load(f)
            else:
                self.initialize_status()
        return self.current_status

    def start_reservation(self, chat_id):
        """ì˜ˆì•½ ì‹œì‘"""
        self.current_status = {
            'is_running': True,
            'should_stop': False,
            'chat_id': chat_id,
            'last_check': datetime.now().isoformat()
        }
        self.stop_event.clear()  # ì¤‘ë‹¨ ì´ë²¤íŠ¸ ì´ˆê¸°í™”
        self._save_status(self.current_status)
        logger.info(f"ì˜ˆì•½ ì‹œì‘ - chat_id: {chat_id}")

    def stop_reservation(self, chat_id):
        """ì˜ˆì•½ ì¤‘ë‹¨"""
        status = self._load_status()
        if status and str(status['chat_id']) == str(chat_id):
            status['should_stop'] = True
            self.stop_event.set()  # ì¤‘ë‹¨ ì´ë²¤íŠ¸ ì„¤ì •
            self._save_status(status)
            logger.info(f"ì˜ˆì•½ ì¤‘ë‹¨ ìš”ì²­ - chat_id: {chat_id}")
            return True
        return False

    def should_stop(self, chat_id):
        """ì¤‘ë‹¨ ìƒíƒœ í™•ì¸"""
        status = self._load_status()
        return status and str(status['chat_id']) == str(chat_id) and status['should_stop']

    def cleanup(self):
        """ìƒíƒœ ì •ë¦¬"""
        try:
            self.initialize_status()
            logger.info("ìƒíƒœ ì´ˆê¸°í™” ì™„ë£Œ")
        except Exception as e:
            logger.error(f"ìƒíƒœ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

class TrainReservation:
    def __init__(self):
        korail_user = os.environ.get('KORAIL_USER')
        korail_pass = os.environ.get('KORAIL_PASS')
        srt_user = os.environ.get('SRT_USER_num')  # SRT_USER_num ì‚¬ìš©
        srt_pass = os.environ.get('SRT_PASS')

        # ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê¹… ì¶”ê°€
        logger.info(f"SRT User: {srt_user}")
        
        if not all([korail_user, korail_pass, srt_user, srt_pass]):
            logger.error("í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            sys.exit(1)

        self.korail = Korail(korail_user, korail_pass, auto_login=True)
        self.srt = SRT(
            srt_user.strip(),  # ê³µë°± ì œê±°
            srt_pass.strip()   # ê³µë°± ì œê±°
        )

        # ë¯¼ê°í•œ ì •ë³´ë¥¼ í•˜ë“œì½”ë”©í•˜ì§€ ì•Šê³  í™˜ê²½ ë³€ìˆ˜ ì‚¬ìš©
        self.korail = Korail(korail_user, korail_pass, auto_login=True)
        self.srt = SRT(srt_user, srt_pass)
        self.srt.login()
        self.RATE_LIMIT_DELAY = 0.9
        self.ATTEMPTS_PER_CYCLE = 10
        self.status_manager = StatusManager()
        self.reservation_task = None

    def search_and_reserve(self, dep, arr, date, time, service, chat_id, context):
        """ì˜ˆì•½ í”„ë¡œì„¸ìŠ¤ ì‹œì‘"""
        self.status_manager.start_reservation(chat_id)
        loop = asyncio.get_event_loop()
        self.reservation_task = loop.create_task(
            self._reserve_process(dep, arr, date, time, service, chat_id, context)
        )

    async def _reserve_process(self, dep, arr, date, time, service, chat_id, context):
        try:
            if service == 'KTX':
                return await self.reserve_ktx(dep, arr, date, time, chat_id, context)
            elif service == 'SRT':
                return await self.reserve_srt(dep, arr, date, time, chat_id, context)
            else:
                return "ì˜ëª»ëœ ì—´ì°¨ ì„œë¹„ìŠ¤ ì„ íƒì…ë‹ˆë‹¤."
        except asyncio.CancelledError:
            logger.info("ì˜ˆì•½ í”„ë¡œì„¸ìŠ¤ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
            await context.bot.send_message(chat_id=chat_id, text="ì˜ˆì•½ í”„ë¡œì„¸ìŠ¤ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
            raise
        finally:
            self.status_manager.cleanup()

    def stop_reservation_task(self):
        if self.reservation_task:
            self.reservation_task.cancel()
            self.reservation_task = None

    async def reserve_ktx(self, dep, arr, date, time, chat_id, context):
        total_attempt_count = 0
        loop = asyncio.get_event_loop()

        while not self.status_manager.stop_event.is_set():
            for _ in range(self.ATTEMPTS_PER_CYCLE):
                if self.status_manager.stop_event.is_set():
                    logger.info("KTX ì˜ˆì•½ ì¤‘ë‹¨ ìš”ì²­ ê°ì§€")
                    return "ì‚¬ìš©ì ìš”ì²­ìœ¼ë¡œ ì˜ˆì•½ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤."

                total_attempt_count += 1
                try:
                    if self.status_manager.stop_event.is_set():
                        return "ì‚¬ìš©ì ìš”ì²­ìœ¼ë¡œ ì˜ˆì•½ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤."

                    trains = await loop.run_in_executor(None, partial(
                        self.korail.search_train,
                        dep, arr, date, time,
                        passengers=[AdultPassenger(1)],
                        train_type=[TrainType.KTX],
                        include_no_seats=True
                    ))

                    if not trains:
                        # ì—´ì°¨ê°€ ì—†ìœ¼ë©´ ë‹¤ìŒ ë£¨í”„ë¡œ
                        await asyncio.sleep(self.RATE_LIMIT_DELAY)
                        continue

                    train = trains[0]

                    train_info = (f"{date[:4]}/{date[4:6]}/{date[6:]} "
                                f"{train.dep_time[:2]}:{train.dep_time[2:4]} "
                                f"{train.train_no}ë²ˆ ì—´ì°¨")

                    try:
                        reservation = await loop.run_in_executor(None, partial(
                            self.korail.reserve,
                            train,
                            [AdultPassenger(1)]
                        ))

                        if reservation:
                            # ì˜ˆì•½ ì„±ê³µ
                            success_msg = (
                                f"KTX ì˜ˆì•½ ì„±ê³µ!\n"
                                f"ì—´ì°¨: {train_info}\n"
                                f"ì¶œë°œ: {train.dep_name} -> ë„ì°©: {train.arr_name}\n"
                                f"ì˜ˆì•½ë²ˆí˜¸: {reservation.rsv_id}"
                            )
                            logger.info(f"KTX ì˜ˆì•½ ì„±ê³µ: {train_info}")
                            await context.bot.send_message(chat_id=chat_id, text=success_msg)

                            # ê²°ì œ ì²˜ë¦¬ ì‹œì‘
                            payment_handler = KorailAutoPayment()
                            reservation_info = {
                                'rsv_id': reservation.rsv_id,
                                'train_info': train_info
                            }
                            await payment_handler.process_payment(reservation_info, chat_id, context)

                            return success_msg

                    except Exception as e:
                        error_message = str(e)
                        logger.error(f"KTX ì˜ˆì•½ ì‹¤íŒ¨ - {train_info} - ì‚¬ìœ : {error_message}")

                        if 'WRR800029' in error_message:
                            # ë™ì¼í•œ ì˜ˆì•½ì´ ì´ë¯¸ ì¡´ì¬í•¨ => ì¦‰ì‹œ ì¢…ë£Œ
                            warning_msg = (
                                f"ì´ë¯¸ ë™ì¼í•œ ì˜ˆì•½ì´ ì¡´ì¬í•©ë‹ˆë‹¤. ì˜ˆì•½ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.\n"
                                f"ì—´ì°¨: {train_info}"
                            )
                            logger.info(warning_msg)
                            await context.bot.send_message(chat_id=chat_id, text=warning_msg)
                            return warning_msg  # ì—¬ê¸°ì„œ ì¦‰ì‹œ í•¨ìˆ˜ ì¢…ë£Œ

                    await asyncio.sleep(self.RATE_LIMIT_DELAY)

                except Exception as e:
                    logger.error(f"KTX ê²€ìƒ‰ ì˜¤ë¥˜: {str(e)}")
                    await asyncio.sleep(self.RATE_LIMIT_DELAY)

            # ì—¬ê¸°ê¹Œì§€ ì™”ë‹¤ë©´ í•´ë‹¹ ì‚¬ì´í´ì—ì„œ ì˜ˆì•½ ì„±ê³µ/ì¢…ë£Œ ì¡°ê±´ì„ ëª» ì°¾ìŒ
            if self.status_manager.stop_event.is_set():
                return "ì‚¬ìš©ì ìš”ì²­ìœ¼ë¡œ ì˜ˆì•½ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤."

            logger.info(f"KTX ì˜ˆì•½ ì§„í–‰ ì¤‘... (ì‹œë„ íšŸìˆ˜: {total_attempt_count}íšŒ)")
            await asyncio.sleep(0.5)

        return "ì˜ˆì•½ í”„ë¡œì„¸ìŠ¤ê°€ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤."


    async def reserve_srt(self, dep, arr, date, time, chat_id, context):
        # ì„¸ì…˜ ì¬ì„¤ì • ë¡œì§ ê°•í™”
        try:
            self.srt = SRT(os.environ.get('SRT_USER'), os.environ.get('SRT_PASS'))
            self.srt.login()
        except Exception as e:
            logger.error(f"SRT ë¡œê·¸ì¸ ì‹¤íŒ¨: {str(e)}")
            await context.bot.send_message(chat_id=chat_id, text="SRT ë¡œê·¸ì¸ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.")
            await asyncio.sleep(2)

        total_attempt_count = 0
        loop = asyncio.get_event_loop()

        while not self.status_manager.stop_event.is_set():
            for _ in range(self.ATTEMPTS_PER_CYCLE):
                if self.status_manager.stop_event.is_set():
                    return "ì‚¬ìš©ì ìš”ì²­ìœ¼ë¡œ ì˜ˆì•½ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤."

                total_attempt_count += 1
                try:
                    # NetFunnel ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•œ ë”œë ˆì´ ì¶”ê°€
                    await asyncio.sleep(1.5)  # 1.5ì´ˆ ëŒ€ê¸°

                    trains = await loop.run_in_executor(None, partial(
                        self.srt.search_train,
                        dep, arr, date, time,
                        available_only=False
                    ))

                    if not trains:
                        continue

                    train = trains[0]
                    # dep_station, arr_station ëŒ€ì‹  dep_name, arr_name ì‚¬ìš©
                    train_info = (f"{date[:4]}/{date[4:6]}/{date[6:]} "
                                  f"{train.dep_time[:2]}:{train.dep_time[2:4]} "
                                  f"SRT {train.train_number}ë²ˆ ì—´ì°¨")

                    try:
                        # NetFunnel ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•œ ë”œë ˆì´ ì¶”ê°€
                        await asyncio.sleep(1)

                        reservation = await loop.run_in_executor(None, partial(
                            self.srt.reserve,
                            train,
                            special_seat=SeatType.GENERAL_FIRST
                        ))

                        if reservation:
                            success_msg = (
                                f"SRT ì˜ˆì•½ ì„±ê³µ!\n"
                                f"ì—´ì°¨: {train_info}\n"
                                f"ì¶œë°œ: {train.dep_station_name} -> ë„ì°©: {train.arr_station_name}\n"
                                f"ì˜ˆì•½ë²ˆí˜¸: {reservation.reservation_number}"
                            )
                            logger.info(f"SRT ì˜ˆì•½ ì„±ê³µ: {train_info}")
                            await context.bot.send_message(chat_id=chat_id, text=success_msg)

                            # ê²°ì œ ì²˜ë¦¬ ì‹œì‘
                            payment_handler = SRTAutoPayment()
                            reservation_info = {
                                'reservation_number': reservation.reservation_number,
                                'train_info': train_info
                            }
                            await payment_handler.process_payment(reservation_info, chat_id, context)

                            return success_msg

                    except Exception as e:
                        error_message = str(e)
                        logger.error(f"SRT ì˜ˆì•½ ì‹¤íŒ¨ - {train_info} - ì‚¬ìœ : {error_message}")
                        await asyncio.sleep(1)  # ì˜¤ë¥˜ ë°œìƒ ì‹œ ì¶”ê°€ ë”œë ˆì´

                except Exception as e:
                    logger.error(f"SRT ê²€ìƒ‰ ì˜¤ë¥˜: {str(e)}")
                    await asyncio.sleep(2)  # ê²€ìƒ‰ ì˜¤ë¥˜ ì‹œ ë” ê¸´ ë”œë ˆì´

            if self.status_manager.stop_event.is_set():
                return "ì‚¬ìš©ì ìš”ì²­ìœ¼ë¡œ ì˜ˆì•½ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤."

            logger.info(f"SRT ì˜ˆì•½ ì§„í–‰ ì¤‘... (ì‹œë„ íšŸìˆ˜: {total_attempt_count}íšŒ)")
            await asyncio.sleep(1)

        return "ì˜ˆì•½ í”„ë¡œì„¸ìŠ¤ê°€ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤."

train_reservation = TrainReservation()

async def start_search(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('ì˜ˆì•½í•  ì—´ì°¨ ì„œë¹„ìŠ¤ë¥¼ ì„ íƒí•˜ì„¸ìš” (/ktx ë˜ëŠ” /srt):')
    return TRAIN_SERVICE

async def set_ktx(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['service'] = 'KTX'
    await update.message.reply_text('ì¶œë°œì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”:')
    return DEPARTURE

async def set_srt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['service'] = 'SRT'
    await update.message.reply_text('ì¶œë°œì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”:')
    return DEPARTURE

async def departure(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['departure'] = update.message.text
    await update.message.reply_text('ë„ì°©ì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”:')
    return DESTINATION

async def destination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['destination'] = update.message.text
    await update.message.reply_text('ì—¬í–‰ ë‚ ì§œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: 20240324):')
    return DATE

async def date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        input_date = update.message.text
        # ë‚ ì§œ í˜•ì‹ ê²€ì¦
        datetime.strptime(input_date, '%Y%m%d')
        context.user_data['date'] = input_date
        await update.message.reply_text('ì¶œë°œ ì‹œê°„ì„ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: 130000):')
        return TIME
    except ValueError:
        await update.message.reply_text('ì˜¬ë°”ë¥¸ ë‚ ì§œ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤. YYYYMMDD í˜•ì‹ìœ¼ë¡œ ë‹¤ì‹œ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: 20240324):')
        return DATE

async def time(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        input_time = update.message.text
        datetime.strptime(input_time, '%H%M%S')
        context.user_data['time'] = input_time
        await update.message.reply_text('ì˜ˆì•½ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì¤‘ë‹¨í•˜ë ¤ë©´ /stop ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.')

        # ì˜ˆì•½ í”„ë¡œì„¸ìŠ¤ë¥¼ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹œì‘
        train_reservation.search_and_reserve(
            context.user_data['departure'],
            context.user_data['destination'],
            context.user_data['date'],
            context.user_data['time'],
            context.user_data['service'],
            update.effective_chat.id,
            context
        )

        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text('ì˜¬ë°”ë¥¸ ì‹œê°„ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤. HHMMSS í˜•ì‹ìœ¼ë¡œ ë‹¤ì‹œ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: 130000):')
        return TIME

async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """ì˜ˆì•½ ì¤‘ë‹¨ ëª…ë ¹ì–´ ì²˜ë¦¬"""
    chat_id = update.effective_chat.id
    logger.info(f"Stop ëª…ë ¹ì–´ ìˆ˜ì‹  from user {chat_id}")

    train_reservation.stop_reservation_task()

    if train_reservation.status_manager.stop_reservation(chat_id):
        await update.message.reply_text('ì˜ˆì•½ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...')
    else:
        await update.message.reply_text('í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì˜ˆì•½ì´ ì—†ìŠµë‹ˆë‹¤.')

    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('ì˜ˆì•½ í”„ë¡œì„¸ìŠ¤ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.')
    return ConversationHandler.END

def main():
    # ì´ë²¤íŠ¸ ë£¨í”„ ì„¤ì •
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    # í™˜ê²½ ë³€ìˆ˜ì—ì„œ Telegram Bot Token ê°€ì ¸ì˜¤ê¸°
    telegram_bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')

    # í™˜ê²½ ë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬
    if not telegram_bot_token:
        logger.error("TELEGRAM_BOT_TOKEN í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        sys.exit(1)

    application = Application.builder().token(telegram_bot_token).build()

    # stop ëª…ë ¹ì–´ í•¸ë“¤ëŸ¬ë¥¼ ìµœìš°ì„  ë“±ë¡
    application.add_handler(CommandHandler('stop', stop), group=-1)

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start_search)],
        states={
            TRAIN_SERVICE: [CommandHandler('ktx', set_ktx), CommandHandler('srt', set_srt)],
            DEPARTURE: [MessageHandler(filters.TEXT & ~filters.COMMAND, departure)],
            DESTINATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, destination)],
            DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, date)],
            TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, time)]
        },
        fallbacks=[CommandHandler('stop', stop), CommandHandler('cancel', cancel)]
    )

    application.add_handler(conv_handler)

    # ë†’ì€ ìš°ì„ ìˆœìœ„ë¡œ stop í•¸ë“¤ëŸ¬ ë‹¤ì‹œ ë“±ë¡
    application.add_handler(CommandHandler('stop', stop), group=1)

    application.run_polling()

if __name__ == '__main__':
    main()





